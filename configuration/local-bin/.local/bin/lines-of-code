#!/usr/bin/env bash

# NAME
#    lines-of-code - simple report of lines of code
#
# SYNOPSIS
#    lines-of-code [options] [path path...]
#
# OPTIONS
#    --files      = Output information about all discovered files
#    --pretty     = Pretty print the table
#    --graph      = Output a pie bar of the numbers
#    --strip-path = Do not print the "path" column
#    --type t     = Only print the row for type "t"
#    --total      = Short hand for "--type Total"
#    --lines      = Only output number of total lines
#    --help, -h   = Print this usage info.
#
# OUTPUT
#    TSV with one line per path per lang:
#    <path> <lang> <lines> <code> <comments> <blanks>
#
#    By default, only supplied paths will be have rows.  With
#    --files, the rows will be for all discovered files.
#
# DEPENDENCIES
#   - tokei
#   - sed
#   - jq

set -o nounset
set -o errexit
set -o pipefail
#set -o xtrace

function Main() {
  local files=0
  local pretty=0
  local graph=0
  local print_path=1
  local lines_only=0
  local type=

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --files)      files=1 ;;
      --pretty)     pretty=1 ;;
      --graph)      graph=1 ;;
      --strip-path) print_path=0 ;;
      --type)       shift && type="$1" ;;
      --total)      type="Total" ;;
      --lines)      lines_only=1 ;;
      --help | -h)  Usage "$@"; exit 0 ;;
      *)            break ;;
    esac
    shift
  done

  case "$files" in
    0) SummaryTable "${@:-$PWD}" ;;
    1) FilesTable "${@:-$PWD}" ;;
  esac \
    | if [[ -n "${type}" ]]; then FilterType "$type"; else cat; fi  \
    | if [[ $print_path -eq 1 ]]; then cat; else StripPath; fi  \
    | if [[ $pretty -eq 1 ]]; then PrettyPrint; else cat; fi \
    | if [[ $lines_only -eq 1 ]]; then LinesOnly; else cat; fi

  # Note: Recalculating for graph since it seems fast enough
  if [[ $graph -eq 1 ]]; then
    case "$files" in
      0) SummaryTable "${@:-$PWD}" ;;
      1) FilesTable "${@:-$PWD}" ;;
    esac \
      | if [[ -n "${type}" ]]; then FilterType "$type"; else cat; fi  \
      | Graph
  fi
}

function Error() {
  echo "ERROR: $@" >&2
  echo >&2
  Usage >&2
  exit 1
}

function Usage() {
  sed -E -f <(GetSection "UsageSedScript") $0
}

# Get a delimited section of this file
function GetSection() {
  local section="$1"
  sed -En "/^#.*${section}:Start/,/^#.*${section}:End/ { s/^# ?//; p; }" $0 \
    | sed '1d; $d'
}

function SummaryTable() {
  PrintHeader
  for path in "$@"; do
    tokei --output="json" --compact --hidden --exclude .git "$path" \
      | jq -f <(GetSection "JqSummaryScript") \
      | jq --raw-output --arg path "$path" \
        '[$path, .type, .lines, .code, .comments, .blanks] | @tsv'
  done
}

function FilesTable() {
  PrintHeader
  for path in "$@"; do
    tokei --output="json" --compact --hidden --exclude .git "$path" --files \
      | jq -f <(GetSection "JqFilesScript") \
      | jq --raw-output \
        '[.path, .type, .lines, .code, .comments, .blanks] | @tsv'
  done
}

function PrintHeader() {
  printf "Path\tType\tLines\tCode\tComments\tBlanks\n"
}

function PrettyPrint() {
  local heading="$(tput smul)"
  local reset="$(tput sgr0)"
  column -s $'\t' -t \
    | sed -E "1s/[^ 	]+/${heading}&${reset}/g"
}

function FilterType() {
  local type="$1"
  awk -v type="$type" 'NR == 1; $2 == type;'
}

function LinesOnly() {
  awk 'NR > 1 {print $3}'
}

function StripPath() {
  cut -f2-
}

function Graph() {
  tail +2 \
    | grep -v Total \
    | cut -f2,3 \
    | datamash transpose \
    | {
      read headers
      xargs pie-bar
      echo "$headers" \
        | tr $'\t ' $'\n_' \
        | xargs pie-bar --key \
        | paste - - - \
        | column -s $'\t' -t
    } || true
}

Main "$@"

exit 0

# The rest of this file is not executed, so can hold scripts for
# different languages etc.  Use `GetSection xxx` to obtain the
# text for a particular section.

#~~~~~~~~~~~~~~~~~~~~~~~~~~~ UsageSedScript:Start ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# #n
# /^#!/ n
# /^#/ {
#   :heading
#   /^#/ {
#     s/^# ?//
#     p
#     n
#     b heading
#   }
#   q
# }
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~ UsageSedScript:End ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#~~~~~~~~~~~~~~~~~~~~~~~~~~~ JqSummaryScript:Start ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# to_entries[] | {
#   type: .key,
#   lines: .value | (.code + .comments + .blanks),
#   code: .value.code,
#   comments: .value.comments,
#   blanks: .value.blanks,
# }
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~ JqSummaryScript:End ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~k

#~~~~~~~~~~~~~~~~~~~~~~~~~~~ JqFilesScript:Start ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# to_entries[] | .key as $type | .value.reports[] | {
#   type: $type,
#   path: .name,
#   lines: .stats | (.code + .comments + .blanks),
#   code: .stats.code,
#   comments: .stats.comments,
#   blanks: .stats.blanks
# }
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~ JqFilesScript:End ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~k
