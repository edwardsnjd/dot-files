#!/usr/bin/env bash

# Create and access a docker environment for the current directory.
#
# Usage:
#  dockerenv <command> [args...]
#  dockerenv help

# Constants

# Where the host directory is mounted
MOUNT_TARGET="/work"

# Used when printing the name of this script
EXE_NAME="dockerenv"
# Used on containers to indicate they are managed by this script
FLAG_LABEL="com.edwardsnjd.dockerenv"
# Used on containers to store the mounted host directory
MOUNT_LABEL="com.edwardsnjd.dockerenv.mount"

# Commands

function main() {
  local command="${1:-shell}"
  shift

  case "$command" in
    up|start|run)
      up "$@";;
    list|ls)
      list "$@";;
    shell|exec)
      shell "$@";;
    down|stop|kill|rm)
      dwn "$@";;
    binstub)
      binstub "$@";;
    binstubs)
      binstubs "$@";;
    help)
      hlp "$@";;
    *)
      unknown "$command";;
  esac
}

function up() {
  local image="${1:-${DOCKERENV_IMAGE}}"
  shift
  local name="$(containername)"
  [ -z "$image" ] && echo "Image required, see help" >/dev/stderr && exit 1
  docker run \
     --interactive \
     --tty \
     --detach \
     --volume "${PWD}":"${MOUNT_TARGET}" \
     --label "${MOUNT_LABEL}=${PWD}" \
     --label "${FLAG_LABEL}" \
     --workdir "${MOUNT_TARGET}" \
     --name="$name" \
     "$@" \
     "$image"
}

function list() {
  docker container ls \
     --filter="label=${FLAG_LABEL}" \
     --format="$(listformat)" \
     "$@"
}

function shell() {
  local id="$(activeid)"
  [ -z "$id" ] && {
    echo "Error: No $EXE_NAME container active" > /dev/stderr
    exit 1
  }

  local reldir="$(activereldir)"

  local command="${1:-bash}"
  shift

  docker exec \
     --interactive \
     --tty \
     --workdir "${MOUNT_TARGET}/${reldir}" \
     "${id}" \
     "${command}" \
     "$@"
}

function dwn() {
  local id="$(activeid)"
  [ -z "$id" ] && {
    echo "Error: No $EXE_NAME container active" > /dev/stderr
    exit 1
  }

  docker rm \
     --force \
     "$@" \
     "${id}"
}

function containername() {
  # Include some randomness to reduce name collision
  printf "dockerenv-%s-%05d" $(basename ${PWD}) $RANDOM
}

# Return info about the active container
# {length of rel path} {rel path} {ID}
function activeinfo() {
  docker ps \
    --filter="label=${FLAG_LABEL}" \
    --format="{{.Label \"${MOUNT_LABEL}\"}}\t{{.ID}}" \
  | awk -v pwd="$PWD" -v OFS=$'\t' \
    ' index(pwd, $1) == 1 {                 # if at or below mounted dir
        $1 = "." substr(pwd, length($1)+1)  # find relative path
        print length($1), $1, $2            # return length (shortest is best)
      }
    ' \
  | sort -n -k1,1 \
  | head -1
}

# Return the ID of the active container
function activeid() {
  activeinfo | cut -f3
}

# Return the relative directory in the active container
function activereldir() {
  activeinfo | cut -f2
}

# Build the Go template string to list containers
function listformat() {
  local id="$(activeid)"
  echo "\
table \
{{ .ID }}\t\
{{ .Image }}\t\
{{ .Status }}\t\
{{ .Label \"${MOUNT_LABEL}\" }}\t\
{{ if eq .ID \"${id}\" }}(*){{ end }}\
"
}

function binstub() {
  local name="$1"
  [ -z "$name" ] && echo "Name required, see help" >/dev/stderr && exit 1

  local newalias="dockerenv exec $@"

  cat <<-END
		! alias ${name} &> /dev/null
		&& alias ${name}="${newalias}"
		&& (echo "# Success! Added alias:" && alias ${name})
		|| (echo "# Nope! Existing alias:" && alias ${name} && exit 1);
	END
}

function binstubs() {
  for name in "$@"
  do
    binstub "${name}"
  done
}

function unknown() {
  echo "Sorry, unknown command: \"$1\""
  exit 1
}

function hlp() {
  cat <<-END
		NAME
        $EXE_NAME - docker dev environments

		SYNOPSIS
        $EXE_NAME [command] [options]

		USAGE
		    The assumption is that your project does not have a special Dockerfile
		    but you have a particular docker image available containing some cli
		    tools that you'd like access to.  This script has a few commands that
		    can start, use, and destroy a companion container for a particular
		    directory.

		    The container and associated tools will work from that particular
		    directory and its descendants.

		    Changing directory to descendants is respected when running commands
		    inside the container i.e. commands for the container should use relative
		    paths from the current working directory, not the original mounted
		    directory.

		    If the current working directory is under the mount directories of
        multiple $EXE_NAME containers then the closest one is used.

		    Creating a custom Dockerfile is not at all a bad idea but if you have a
		    large number of projects with identical development environment
		    requirements then it can be conveninent to make those available without
		    maintaining identical Dockerfiles.

		    This script just provides some sugar for the underlying docker commands
		    you'd use.  The mechanism for identifying the associated container for
		    the current working directory is the path of the directory that the
		    associated container was started from.  That has obvious drawbacks but
		    is often enough.

		    Example - Local ruby project but no ruby installed:
		        $ cd /code/project1           # cd to root of project
		        $ type ruby                   # confirm no ruby on host
		        -bash: type: ruby: not found
            $ $EXE_NAME up ruby:alpine     # start ruby container
		        ...
            $ $EXE_NAME exec ruby foo.rb   # run some ruby
		        ...
            $ $EXE_NAME exec irb           # drop into ruby REPL
		        ...
            $ $EXE_NAME down
		        dockerenv-project1

		    Example - Using binstub for easier access to container commands:
		        $ cd /code/project1           # cd to root of project
            $ $EXE_NAME up ruby:alpine     # start ruby container
		        ...
            $ $EXE_NAME binstubs ruby irb  # add aliases for ruby and irb
		        ...
		        $ ruby foo.rb                 # run some ruby
		        ...
		        $ irb                         # drop into ruby REPL
		        ...
		        $ unalias ruby irb            # remove aliases
            $ $EXE_NAME down
		        dockerenv-project1

        Example - Listing $EXE_NAME containers:
            $ $EXE_NAME ls                 # list containers
		        CONTAINER ID   IMAGE         STATUS          mount
            $ $EXE_NAME up ruby:alpine     # start ruby container
		        ...
            $ $EXE_NAME ls                 # list containers
		        CONTAINER ID   IMAGE         STATUS          mount
		        c2d002896add   ruby:alpine   Up 10 seconds   /code/project1   (*)
		        ddddddddeeee   ruby:alpine   Up 10 minutes   /code/project2

		COMMANDS
		    up|start|run [image] [options]
		      Start a devenv container in the background.
		
		      If supplied, image is the docker image to run.  If no image is
		      supplied the environment variable DOCKERENV_IMAGE is used.
		
		      If supplied, options are passed to docker run.  In order to supply
		      any run options, the image is required.  To use the default:
            $EXE_NAME up \$DOCKERENV_IMAGE [options]
		
		    list|ls [options]
		      List all devenv containers, indicating if one is active for this
		      directory.
		
		      If supplied, options are passed to docker ls.
		
		    shell|exec [command]
		      Run a command inside a devenv container.
		
		      If supplied [command] is the command to run in the container.  If
		      not supplied, bash will be used instead.
		
		    down|stop|kill|rm [options]
		      Stop a devenv container.
		
		      If supplied, options are passed to docker rm.
		
		    binstub name [args...]
		      Output the text of a bash script to setup an alias suitable for use
		      as a bin stub in the current directory.  To create the alias, eval
		      the raw text:
            $ eval \$($EXE_NAME binstub foo)  # create temporary alias
		        $ foo somefile.foo                # use alias as if local
		        $ unalias foo                     # remove the alias
		
		      name is the program to alias, and is also used as the name of the
		      function.
		
		      If supplied args are additional arguments supplied to the named
		      program via the alias.
		
		    binstubs [name...]
		      Convenient way to create binstubs for a number of names.  To create
		      the alias eval the raw text:
            $ eval \$($EXE_NAME binstubs irb ruby)  # create aliases
		        $ ruby foo.rb                           # use aliases
		        $ irb
		        $ unalias irb ruby                      # remove them
		
		      Argument passing is not possible with this command.  If the named
		      program needs arguments baked into the alias then use binstub.
		END
}

# Entry point

main "$@"
