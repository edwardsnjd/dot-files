#!/usr/bin/env bash

# Create and access a docker environment for the current directory.
#
# Usage:
#  dockerenv <command> [args...]
#  dockerenv help

# Constants

# Where the host directory is mounted
MOUNT_TARGET="/work"

# Used on containers to indicate they are managed by this script
FLAG_LABEL="com.edwardsnjd.dockerenv"
# Used on containers to store the mounted host directory
MOUNT_LABEL="com.edwardsnjd.dockerenv.mount"
# Used to list containers
LIST_FORMAT="\
table \
{{ .ID }}\t\
{{ .Image }}\t\
{{ .Status }}\t\
{{ .Label \"${MOUNT_LABEL}\" }}\t\
{{ if eq (.Label \"${MOUNT_LABEL}\") \"${PWD}\" }}(*){{ end }}\
"

# Commands

function main() {
  local command="${1:-shell}"
  shift

  case "$command" in
    up|start|run)
      up "$@";;
    list|ls)
      list "$@";;
    shell|exec)
      shell "$@";;
    down|stop|kill|rm)
      dwn "$@";;
    binstub)
      binstub "$@";;
    binstubs)
      binstubs "$@";;
    help)
      hlp "$@";;
    *)
      unknown "$command";;
  esac
}

function up() {
  local image="${1:-${DOCKERENV_IMAGE}}"
  shift
  local name="$(containername)"
  [ -z "$image" ] && echo "Image required, see help" >/dev/stderr && exit 1
  docker run \
     --interactive \
     --tty \
     --detach \
     --volume "${PWD}":"${MOUNT_TARGET}" \
     --label "${MOUNT_LABEL}=${PWD}" \
     --label "${FLAG_LABEL}" \
     --workdir "${MOUNT_TARGET}" \
     --name="$name" \
     "$@" \
     "$image"
}

function list() {
  docker container ls \
     --filter="label=${FLAG_LABEL}" \
     --format="${LIST_FORMAT}" \
     "$@"
}

function shell() {
  local name="$(containername)"
  local command="${1:-bash}"
  shift
  docker exec \
     --interactive \
     --tty \
     "${name}" \
     "${command}" \
     "$@"
}

function dwn() {
  local name="$(containername)"
  docker rm \
     --force \
     "$@" \
     "${name}"
}

function containername() {
  echo "dockerenv-$(basename ${PWD})"
}

function binstub() {
  local name="$1"
  [ -z "$name" ] && echo "Name required, see help" >/dev/stderr && exit 1

  local newalias="dockerenv exec $@"

  cat <<-END
		! alias ${name} &> /dev/null
		&& alias ${name}="${newalias}"
		&& (echo "# Success! Added alias:" && alias ${name})
		|| (echo "# Nope! Existing alias:" && alias ${name} && exit 1);
	END
}

function binstubs() {
  for name in "$@"
  do
    binstub "${name}"
  done
}

function unknown() {
  echo "Sorry, unknown command: \"$1\""
  exit 1
}

function hlp() {
  local exename="$(basename $0)"
  cat <<-END
		NAME
		    $exename - docker dev environments

		SYNOPSIS
		    $exename [command] [options]

		USAGE
		    The assumption is that your project does not have a special Dockerfile
		    but you have a particular docker image available containing some cli
		    tools that you'd like access to.  This script has a few commands that
		    can start, use, and destroy a companion container for a particular
		    directory.

		    The container and associated tools will work from that particular
		    directory and its descendants.

		    Creating a custom Dockerfile is not at all a bad idea but if you have a
		    large number of projects with identical development environment
		    requirements then it can be conveninent to make those available without
		    maintaining identical Dockerfiles.

		    This script just provides some sugar for the underlying docker commands
		    you'd use.  The mechanism for identifying the associated container for
		    the current working directory is the path of the directory that the
		    associated container was started from.  That has obvious drawbacks but
		    is often enough.

		    Example - Local ruby project but no ruby installed:
		        $ cd /code/project1           # cd to root of project
		        $ type ruby                   # confirm no ruby on host
		        -bash: type: ruby: not found
		        $ $exename up ruby:alpine     # start ruby container
		        ...
		        $ $exename exec ruby foo.rb   # run some ruby
		        ...
		        $ $exename exec irb           # drop into ruby REPL
		        ...
		        $ $exename down
		        dockerenv-project1

		    Example - Using binstub for easier access to container commands:
		        $ cd /code/project1           # cd to root of project
		        $ $exename up ruby:alpine     # start ruby container
		        ...
		        $ $exename binstubs ruby irb  # add aliases for ruby and irb
		        ...
		        $ ruby foo.rb                 # run some ruby
		        ...
		        $ irb                         # drop into ruby REPL
		        ...
		        $ unalias ruby irb            # remove aliases
		        $ $exename down
		        dockerenv-project1

		    Example - Listing $exename containers:
		        $ $exename ls                 # list containers
		        CONTAINER ID   IMAGE         STATUS          mount
		        $ $exename up ruby:alpine     # start ruby container
		        ...
		        $ $exename ls                 # list containers
		        CONTAINER ID   IMAGE         STATUS          mount
		        c2d002896add   ruby:alpine   Up 10 seconds   /code/project1   (*)
		        ddddddddeeee   ruby:alpine   Up 10 minutes   /code/project2

		COMMANDS
		    up|start|run [image] [options]
		      Start a devenv container in the background.
		
		      If supplied, image is the docker image to run.  If no image is
		      supplied the environment variable DOCKERENV_IMAGE is used.
		
		      If supplied, options are passed to docker run.  In order to supply
		      any run options, the image is required.  To use the default:
		        $exename up \$DOCKERENV_IMAGE [options]
		
		    list|ls [options]
		      List all devenv containers, indicating if one is active for this
		      directory.
		
		      If supplied, options are passed to docker ls.
		
		    shell|exec [command]
		      Run a command inside a devenv container.
		
		      If supplied [command] is the command to run in the container.  If
		      not supplied, bash will be used instead.
		
		    down|stop|kill|rm [options]
		      Stop a devenv container.
		
		      If supplied, options are passed to docker rm.
		
		    binstub name [args...]
		      Output the text of a bash script to setup an alias suitable for use
		      as a bin stub in the current directory.  To create the alias, eval
		      the raw text:
		        $ eval \$($exename binstub foo)  # create temporary alias
		        $ foo somefile.foo                # use alias as if local
		        $ unalias foo                     # remove the alias
		
		      name is the program to alias, and is also used as the name of the
		      function.
		
		      If supplied args are additional arguments supplied to the named
		      program via the alias.
		
		    binstubs [name...]
		      Convenient way to create binstubs for a number of names.  To create
		      the alias eval the raw text:
		        $ eval \$($exename binstubs irb ruby)  # create aliases
		        $ ruby foo.rb                           # use aliases
		        $ irb
		        $ unalias irb ruby                      # remove them
		
		      Argument passing is not possible with this command.  If the named
		      program needs arguments baked into the alias then use binstub.
		END
}

# Entry point

main "$@"
